Тестовое задание для Ростелеком.

Задание находится в **/task.MD**.

## Переменные окружения

Для работы с проектом требуется создать файлы **.env** с переменными окружения для сервисов A, B и docker compose.

Примеры файлов находятся в следующих директориях:
1) Сервис A: **/backend/service_a/env.example**
2) Сервис B: **/backend/service_b/env.example**
3) docker compose: **/ci/local/env.example**

## Docker compose

Для поднятия контейнеров с микросервисами достаточно прописать

```
docker compose up -d --build
```

Docker compose содержит следующие контейнеры:
1) rabbitmq - очередь для сообщений на конфигурацию
2) postgres - БД для сохранения результатов конфигурации с последующим доступом к ним
3) flyway - мигратор для БД
4) service_a - синхронный сервис конфигурации
5) service_b - асинхронный сервис конфигурации

## Асинхронный сервис B

Сервис B работает в двух процессах: первый занят веб-сервером с реализацией на FastAPI, второй слушает очередь RabbitMQ на предмет сообщений о готовой конфигурации устройства и пишет статус конфигурации в БД.

Также в директории сервиса находится скрипт **/configurator.py**. Он работает в 4 процессах. Сначала он ждет сообщения на конфигурацию в RabbitMQ, далее обращается к синхронному сервису A, получает от него ответ и кладет результат в очередь с результами.

## Настройка RabbitMQ

Поднятый в docker compose RabbitMQ имеет свой UI, который находится по адресу **http://localhost:15672/**.

Для правильный работы системы в нем надо задать Exchange, 2 очереди на конфигурацию и 2 ключа. Их названия находятся в **env.example** сервиса B.

## Архитектура решения

![](/docs/arch.png)

На картинке представлена упрощенная архитектура системы.

Поток данных выглядит следующим образом:
1) Делается POST-запрос на http://<service_b_host>:<service_b_port>/api/v1/equipment/cpe/<eq_id>
2) В БД записывается статус **pending** для текущей задачи
3) Данные для конфигурации записываются в очередь **to_configure**
4) Вызывается скрипт **configurator.py**, который работает в нескольких процессах. Он получает сообщение из **to_configure**
5) Полученное сообщение отправляется в сервис A, который через какое-то время отправляет ответ скрипту
6) Скрипт записывает результат в очередь **configured**
7) Дополнительный процесс сервиса B читает очередь **configured** и записывает статус конфигурации в БД
8) Статус конфигурации можно получить с помощью GET-запроса на http://<service_b_host>:<service_b_port>/api/v1/equipment/cpe/<eq_id>/task/<task_id>